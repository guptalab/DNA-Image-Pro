import java.io.*;
import java.util.*;

public class uniform_shiftgen {

	static String printer1 = "";
	static String printer = "";

	static int colors[];

	// this method will append the given string with new line character to the
	// printer.
	public static void add_string(String s) {
		printer += s + "\n";
	}

	// this method is to take care of tiles_needed variable.because we can not
	// append it directly from start.
	public static void add_string2(String s) {
		printer1 += s + "\n";
	}

	// This method will take input parameter for a tile file. and append the
	// corresponding formated string to printer
	public static void add_tile(int north, int east, int south, int west,
			int color_index) {
		add_string("{" + north + " " + east + " " + south + " " + west + " }("
				+ colors[color_index] + ")");

	}

	public static void create_tile_file(int N, String f_name, int[] shift_arr,
			int color[], int flag) {
		printer1 = "";
		printer = "";

		if (flag == 0) {
			int t = shift_arr[1];
			for (int x = 1; x < shift_arr.length; x++)
				shift_arr[x] = t;
		}
		colors = color;
		String cur_dir = System.getProperty("user.dir");
		try {
			File file = new File(cur_dir + "/" + f_name + ".tiles");
			FileWriter fw = new FileWriter(file.getAbsoluteFile());
			BufferedWriter bw = new BufferedWriter(fw);
			add_string("%Tile file generated by shift generator");
			add_string("%Mentor : Manish Gupta");
			add_string("%Author : Dhaval Trivedi");
			add_string("%Input N = " + N);

			// first line of tile file
			add_string("tile edges matches {{N E S W}*}");
			// we don't know the value of tile_types_needed because this is
			// non-uniform shifting
			// so we will count how many tiles are whenever we add new rule
			// tile.
			// so we will print the first line to the file and then we will
			// print in the last.
			bw.write(printer);
			// reseting printer
			printer = "";
			int tile_types_needed = 3 * N - 1; // N(border row)+N-1(border
			// column)+N (rule tiles)

			// We know the glues_needed will be at most 2*N for any case.
			int glues_needed = 2 * N;

			add_string("num binding types=" + glues_needed);
			add_string("tile edges={");

			// adding seed tile. Eg {9,0,0,9} for N=8
			add_string("%seed tile");
			add_tile( N + 1, 0, 0, N + 1, 0);
			add_string("");
			add_string("%First row. (bottom boundry row)");
			add_string("");
			int prev_row_north[] = new int[N - 1];
			// adding first row tiles
			for (int x = 2, y = N + 1, s = 0; x <= N; x++, y++) {
				int north = x;
				int east = y;
				int south = s;
				int west = y + 1;
				
				int color_index = x - 1;
				prev_row_north[x - 2] = north;
				add_tile(north, east, south, west, color_index);

			}

			add_string("");

			int temp = 1;
			// adding first column tiles
			// do note the use of temp variable. (it will take care of shift
			// from previous row)
			//Eg. if temp is 1 and shift is 1,2,3,4 then for N = 8, temp will become 8,6,3,7
			// and so on. so it will take care of first column(right most
			// column).
			add_string("%First column. (right most column)");
			add_string("");
			for (int x = 2, y =  N + 1, z = 1, s = 0; x <= N; x++, y++, z++) {
				temp = (temp - shift_arr[z]) % N;
				if (temp < 1) {
					temp += N;
				}

				int north = y + 1;
				int east = s;
				int south = y;
				int west = temp;
				int color_index = temp - 1;
				add_tile(north, east, south, west, color_index);
			}
			add_string("");

			HashMap<String, String> hm = new HashMap<String, String>();
			// initializing tile_tipes_needed with 2*N -1 = N-1(first
			// row)+N-1(first column)+1(seeds)
			tile_types_needed = 2 * N - 1;

			// adding rule tiles
			add_string("%Rule tiles");
			add_string("");
			for (int t = 1; t < N; t++) {
				for (int x_index = 0, y = N + 1, z = 1, s = 0; x_index < N - 1; x_index++, y++, z++) {
					int x = prev_row_north[x_index];
					temp = (x - 1 - shift_arr[t]) % N;
					if (temp < 1) {
						temp += N;
					}
					int output = (x - shift_arr[t]) % N;
					if (output < 1) {
						output += N;
					}

					int north = output;
					int east = temp;
					int south = x;
					int west = output;
					int color_index = output - 1;
					prev_row_north[x_index] = north;
					if (hm.containsKey(south + " " + west)) {
						// if already added then you dont need to add again.
						String t1 = hm.get(south + " " + west);
						if (!t1.equals(north + " " + east)) {
							System.out.println("This input is problematic.");
						} else {
							continue;
						}
					} else {
						// if not added the add this tile and inclese
						// tile_types_needed
						hm.put(south + " " + west, north + " " + east);
						tile_types_needed++;
						add_tile(north, east, south, west, color_index);
					}

				}
				add_string("");
			}

			// Computing binding strengths. N 1's and N 2's
			add_string("");
			add_string("}");
			add_string("binding strengths=");
			add_string("{");
			String binding_strengths = "";
			
			for (int x = 0; x < N; x++) {
				binding_strengths += "1 ";
			}
			
			for (int x = 0; x < N; x++) {
				binding_strengths += "2 ";
			}
			add_string(binding_strengths);
			add_string("}");

			// positioning seed tile
			int flake_size = (Integer.highestOneBit(N-1)*2);
			add_string("seed=" + (flake_size-1) + "," + (flake_size-1) + ",1");

			// adding gse,gmc and other important parameters
			add_string("Gse=10");
			add_string("Gmc=19");
			add_string("block=10");

			add_string("size="+flake_size);
			// now we know the total tile types needed.
			add_string2("num tile types=" + tile_types_needed);
			bw.write(printer1);
			bw.write(printer);
			// closing the BufferedWriter
			bw.close();
			// Write successful
			System.out.println("Done");

		} catch (IOException e) {
			// File not found or any other exception
			e.printStackTrace();
		}

	}
}
